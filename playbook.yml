# ğŸš€ Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ø§ Docker ComposeØŒ ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªØ±Ø³ÛŒâ€ŒÙ‡Ø§ Ùˆ Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§
- name: "ğŸš€ Deploy project with Docker Compose, set permissions, and send requests"
  hosts: all
  become: true

  vars:
    # Ù…Ø³ÛŒØ±Ù‡Ø§ÛŒ Ù¾Ø±ÙˆÚ˜Ù‡
    backup_path: "{{ project_path }}/backup"     # Ù…Ø³ÛŒØ± Ø¨Ú©Ø§Ù¾
    info_path: "{{ project_path }}/info"         # Ù…Ø³ÛŒØ± Ø§Ø·Ù„Ø§Ø¹Ø§Øª
    log_path: "{{ project_path }}/log"           # Ù…Ø³ÛŒØ± Ù„Ø§Ú¯ Ù‡Ø§

    # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…Ø´ØªØ±ÛŒØ§Ù†
    portal_database_type: "mysql"
    portal_mysql_root_password: "1234"
    portal_mysql_password: "1234"
    portal_mysql_user: "root"
    portal_mysql_db_name: "calibri_portal"
    pu: "root"
    pp: "1234"
    pd: "calibri_portal"

    gateway_database_type: "mysql"
    gateway_mysql_root_password: "1234"
    gateway_mysql_password: "1234"
    gateway_mysql_user: "calibri_gateway"
    gateway_mysql_db_name: "calibri_gateway"

  tasks:
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ Ùˆ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§
    # âš™ï¸ Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ Ùˆ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ
    - name: "âš™ï¸ Ensure main directories exist"
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      loop:
        - "{{ project_path }}"
        - "{{ backup_path }}"
        - "{{ info_path }}"
        - "{{ log_path }}"

    # ğŸ—ï¸ Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡ Ù…Ø®ØµÙˆØµ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ Ø¯Ø± Ù…Ø³ÛŒØ± Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§
    - name: "ğŸ—ï¸ Ensure customer-specific directories exist in project_path"
      ansible.builtin.file:
        path: "{{ project_path }}/{{ inventory_hostname }}"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ğŸ—„ï¸ Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡ Ù…Ø®ØµÙˆØµ Ù…Ø´ØªØ±ÛŒ Ø¯Ø± Ù…Ø³ÛŒØ± Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÙ‡Ø§
    - name: "ğŸ—„ï¸ Ensure customer directories in backup_path exist"
      ansible.builtin.file:
        path: "{{ backup_path }}/{{ inventory_hostname }}"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ğŸ—ƒï¸ Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ test Ùˆ backup Ø¯Ø± log_path
    - name: "ğŸ—ƒï¸ Ensure directories for test and backup in log_path exist"
      ansible.builtin.file:
        path: "{{ log_path }}/{{ item }}"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      loop:
        - "test"
        - "backup"

    # ğŸ“¦ Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ volumes Ùˆ databases Ø¯Ø± info_path
    - name: "ğŸ“¦ Ensure directories for volumes and databases in info_path exist"
      ansible.builtin.file:
        path: "{{ info_path }}/{{ item }}"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      loop:
        - "volumes"
        - "databases"

    # ğŸ§ª Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ù…ØªÙ†ÛŒ Ø¯Ø± Ù¾ÙˆØ´Ù‡ ØªØ³Øª Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯
    - name: "ğŸ§ª Create a text file in test folder for each customer"
      ansible.builtin.file:
        path: "{{ log_path }}/test/{{ inventory_hostname }}.txt"
        state: touch
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ğŸ›¡ï¸ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ù…ØªÙ†ÛŒ Ø¯Ø± Ù¾ÙˆØ´Ù‡ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯
    - name: "ğŸ›¡ï¸ Create a text file in backup folder for each customer"
      ansible.builtin.file:
        path: "{{ log_path }}/backup/{{ inventory_hostname }}.txt"
        state: touch
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ğŸ“ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ù…ØªÙ†ÛŒ Ø¯Ø± Ù¾ÙˆØ´Ù‡ volumes Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯
    - name: "ğŸ“ Create a text file in volumes folder for each customer"
      ansible.builtin.file:
        path: "{{ info_path }}/volumes/{{ inventory_hostname }}.txt"
        state: touch
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ğŸ“ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ù…ØªÙ†ÛŒ Ø¯Ø± Ù¾ÙˆØ´Ù‡ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯
    - name: "ğŸ“ Create a text file in databases folder for each customer"
      ansible.builtin.file:
        path: "{{ info_path }}/databases/{{ inventory_hostname }}.txt"
        state: touch
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ù…Ø¯ÛŒØ±ÛŒØª Ø´Ú©Ù† Ø¨Ø±Ø§ÛŒ Ú¯ÛŒØªâ€ŒÙ„Ø¨
    # ğŸŒ Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ DNS Ø³Ø±ÙˆÛŒØ³ Shecan Ø¯Ø± resolved.conf Ø§Ú¯Ø± Ù…Ù†Ø¨Ø¹ Ø±ÛŒÙ¾Ùˆ gitlab Ø¨Ø§Ø´Ø¯
    - name: "ğŸŒ Configure Shecan DNS in resolved.conf if repo_source is gitlab"
      ansible.builtin.copy:
        content: |
          # This file is part of systemd.
          #
          # systemd is free software; you can redistribute it and/or modify it
          # under the terms of the GNU Lesser General Public License as published by
          # the Free Software Foundation; either version 2.1 of the License, or
          # (at your option) any later version.

          [Resolve]
          DNS=178.22.122.100 185.51.200.2
          FallbackDNS=8.8.8.8
          #Domains=
          #LLMNR=yes
          #MulticastDNS=yes
          #DNSSEC=no
          #DNSOverTLS=no
          #Cache=yes
          #DNSStubListener=yes
          #ReadEtcHosts=yes
        dest: /etc/systemd/resolved.conf
        mode: '0644'
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1

    # ğŸ”„ Ø±ÛŒØ³ØªØ§Ø±Øª Ø³Ø±ÙˆÛŒØ³ systemd-resolved Ø¯Ø± ØµÙˆØ±Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² GitLab
    - name: "ğŸ”„ Restart systemd-resolved service if repo_source is gitlab"
      ansible.builtin.systemd:
        name: systemd-resolved
        state: restarted
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1

    # ğŸ”— Ø§ÛŒØ¬Ø§Ø¯ Ù„ÛŒÙ†Ú© Ø³Ù…Ø¨Ù„ÛŒÚ© Ø¨Ø±Ø§ÛŒ /etc/resolv.conf Ø¨Ù‡ /run/systemd/resolve/resolv.conf
    - name: "ğŸ”— Create symbolic link for /etc/resolv.conf if repo_source is gitlab"
      ansible.builtin.file:
        src: /run/systemd/resolve/resolv.conf
        dest: /etc/resolv.conf
        state: link
        force: true
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1

    # ğŸ›  ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÛŒ DNSÙ‡Ø§ÛŒ Shecan Ø¯Ø± /etc/resolv.conf (Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²)
    - name: "ğŸ›  Manually set Shecan DNS in /etc/resolv.conf if repo_source is gitlab"
      ansible.builtin.copy:
        content: |
          nameserver 178.22.122.100
          nameserver 185.51.200.2
        dest: /etc/resolv.conf
        mode: '0644'
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ú¯ÛŒØª
    # ğŸ—‚ï¸ ØªØ¹Ø±ÛŒÙ Ù…Ø®Ø§Ø²Ù† Ù¾Ø±ÙˆÚ˜Ù‡
    - name: "ğŸ—‚ï¸ Define project repositories"
      ansible.builtin.set_fact:
        projects:
          - name: "gateway"
            repo: >-
              {{ "git@gitlab.com:nasser-man/calibri.git" if repo_source == "gitlab"
                else "git@github.com:nasserman/calibri.git" }}
            folder: "gateway"
            branch_var: "customer_gateway_git_branches"
            tag_var: "customer_gateway_git_tags"
            compose_file: "docker-compose-gateway.yml.j2"

          - name: "portal"
            repo: >-
              {{ "git@gitlab.com:nasser-man/calibri-portal.git" if repo_source == "gitlab"
                else "git@github.com:nasserman/calibri-portal.git" }}
            folder: "portal"
            branch_var: "customer_portal_git_branches"
            tag_var: "customer_portal_git_tags"
            compose_file: "docker-compose-portal.yml.j2"

          - name: "portal-frontend"
            repo: >-
              {{ "git@gitlab.com:nasser-man/calibri-portal-frontend.git" if repo_source == "gitlab"
                else "git@github.com:nasserman/calibri-portal-frontend.git" }}
            folder: "portal-frontend"
            branch_var: "customer_portal_frontend_git_branches"
            tag_var: "customer_portal_frontend_git_tags"
            compose_file: "docker-compose-portal-frontend.yml.j2"

    # ğŸ” Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒ Ù…Ø´ØªØ±ÛŒ
    - name: "ğŸ› ï¸ Check if customer base folder exists"
      ansible.builtin.stat:
        path: "{{ project_path }}/{{ inventory_hostname }}"
      register: customer_base_dir
      poll: 1
      when: customer_state == 'update'

    # ğŸ› ï¸ Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒ Ù…Ø´ØªØ±ÛŒ Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
    - name: Create a customer directory if needed
      ansible.builtin.file:
        path: "{{ project_path }}/{{ inventory_hostname }}"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1

    # ğŸ“‚ Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒ Ù…Ø´ØªØ±ÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ø±ÙˆÚ˜Ù‡ Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
    - name: "ğŸ“‚ Create a customer directory for each project if needed"
      ansible.builtin.file:
        path: "{{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}"
        state: directory
        mode: '0777'
      loop: "{{ projects }}"
      when: customer_state == 'update'
      poll: 1

    # ğŸ§ Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ù¾ÙˆØ´Ù‡ Ù…Ø®Ø²Ù† Ù…Ø´ØªØ±ÛŒ (Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ø±ÙˆÚ˜Ù‡)
    - name: "ğŸ§ Check if customer project repository exists"
      ansible.builtin.stat:
        path: "{{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}/.git"
      register: customer_repo_check_results
      loop: "{{ projects }}"
      when: customer_state == 'update'
      poll: 1
      delegate_to: localhost

    # ğŸ“¦ ÙˆØ§Ù‚Ø¹ÛŒØª customer_repo_check Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ÛŒÚ© ÙØ±Ù‡Ù†Ú¯ Ù„ØºØª ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯
    - name: "ğŸ“¦ Set customer_repo_check fact as a dictionary"
      ansible.builtin.set_fact:
        customer_repo_check: "{{ dict(customer_repo_check_results.results | map(attribute='item.folder') | list | zip(customer_repo_check_results.results)) }}"
      when: customer_state == 'update'
      poll: 1
      delegate_to: localhost

    # ğŸŒ± Ú©Ù„ÙˆÙ† Ú©Ø±Ø¯Ù† Ø±ÛŒÙ¾Ø§Ø²ÛŒØªÙˆØ±ÛŒâ€ŒÙ‡Ø§ ÙÙ‚Ø· Ø§Ú¯Ø± git Ù‡Ù†ÙˆØ² ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯
    - name: "ğŸŒ± Clone repositories (first ever deploy)"
      ansible.builtin.shell: |
        GIT_SSH_COMMAND="ssh -i {{ playbook_dir }}/id_rsa -o StrictHostKeyChecking=no" \
        git clone -b {{ vars[item.branch_var] | default('master') }} {{ item.repo }} {{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}
      args:
        chdir: "{{ project_path }}/{{ inventory_hostname }}"
      loop: "{{ projects }}"
      poll: 1
      when: customer_state == 'update' and not customer_repo_check[item.folder].stat.exists
      register: clone_result

    # ğŸ”„ Pull Ú©Ø±Ø¯Ù† Ø¢Ø®Ø±ÛŒÙ† ØªØºÛŒÛŒØ±Ø§Øª Ø§Ú¯Ø± git ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯
    - name: "ğŸ”„ Pull repositories (subsequent runs)"
      ansible.builtin.shell: |
        cd {{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}
        git config user.email "samad.elmakchi@gmail.com"
        git config user.name "CI/CD Bot"
        GIT_SSH_COMMAND="ssh -i {{ playbook_dir }}/id_rsa -o StrictHostKeyChecking=no" \
        git pull --no-rebase origin {{ vars[item.branch_var] | default('master') }}
      loop: "{{ projects }}"
      when: customer_state == 'update' and customer_repo_check[item.folder].stat.exists
      register: git_pull_result
      poll: 1
      changed_when: "'Already up to date' not in git_pull_result.stdout"

    # ğŸ—‘ï¸ Ø­Ø°Ù ÙØ§ÛŒÙ„ lock Ø§Ø­ØªÙ…Ø§Ù„ÛŒ
    - name: "ğŸ—‘ï¸ Remove git index.lock if exists in customer folder"
      ansible.builtin.file:
        path: "{{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}/.git/index.lock"
        state: absent
      loop: "{{ projects }}"
      when: customer_state == 'update'
      poll: 1
      delegate_to: localhost

    # âš™ï¸ Ù…Ø±Ø­Ù„Ù‡ Ù†Ø±Ù…Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ù†Ú†â€ŒÙ‡Ø§ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±
    - name: "âš™ï¸ Normalize branch names if invalid"
      ansible.builtin.set_fact:
        normalized_branches: >-
          {{
            dict(
              projects | map(attribute='branch_var') | list |
              zip(
                projects
                | map(attribute='branch_var')
                | map('extract', hostvars[inventory_hostname])
                | map('regex_search', '^(dev|test|main|ahmadi|master)$')
                | map('default', 'main')
              )
            )
          }}
      poll: 1

    # ğŸš¦ Ù…Ø±Ø­Ù„Ù‡ checkout: Ø§Ú¯Ø± tag Ù…Ø´Ø®Øµ Ø´Ø¯Ù‡ Ø¨ÙˆØ¯ØŒ tagØ› Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ†ØµÙˆØ±Øª Ø§Ø² normalized_branches Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
    - name: "ğŸš¦ Checkout specific tag or branch for each project"
      ansible.builtin.shell: |
        cd "{{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}"
        GIT_SSH_COMMAND="ssh -i {{ playbook_dir }}/id_rsa -o StrictHostKeyChecking=no" \
        git fetch --all --tags
        {% if hostvars[inventory_hostname][item.tag_var] | length > 0 %}
        GIT_SSH_COMMAND="ssh -i {{ playbook_dir }}/id_rsa -o StrictHostKeyChecking=no" \
        git checkout "{{ hostvars[inventory_hostname][item.tag_var] }}"
        {% else %}
        GIT_SSH_COMMAND="ssh -i {{ playbook_dir }}/id_rsa -o StrictHostKeyChecking=no" \
        git checkout "{{ normalized_branches[item.branch_var] }}"
        {% endif %}
      loop: "{{ projects }}"
      when: customer_state == 'update'
      delegate_to: localhost
      run_once: false
      poll: 1
      changed_when: false

    # ğŸ” ØªÙ†Ø¸ÛŒÙ… Ù¾Ø±Ù…ÛŒØ´Ù† Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ø±ÙˆÚ˜Ù‡
    - name: "ğŸ” Set permissions to 0777 for cloned repositories"
      ansible.builtin.file:
        path: "{{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}"
        state: directory
        mode: '0777'
      loop: "{{ projects }}"
      poll: 1
      when: customer_state == 'update'

    # ğŸ“‹ Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„ docker-compose Ø§Ø®ØªØµØ§ØµÛŒ
    - name: "ğŸ“‹ Copy docker-compose files to customer project"
      ansible.builtin.template:
        src: "template/{{ item.compose_file }}"
        dest: "{{ project_path }}/{{ inventory_hostname }}/{{ item.folder }}/docker/docker-compose.yml"
        mode: '0777'
        force: yes
      loop: "{{ projects }}"
      poll: 1
      when: customer_state == 'update'

    # ğŸ“ Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† ÙØ§ÛŒÙ„ nginx.conf Ø§Ø®ØªØµØ§ØµÛŒ
    - name: "ğŸ“ Copy nginx.conf files to customer project"
      ansible.builtin.template:
        src: "template/nginx.conf.j2"
        dest: "{{ project_path }}/{{ inventory_hostname }}/portal-frontend/docker/nginx.conf"
        mode: '0777'
        force: yes
      poll: 1
      when: customer_state == 'update'

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ØºÛŒØ± ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø´Ú©Ù† Ø¨Ø±Ø§ÛŒ Ú¯ÛŒØª Ù„Ø¨
    # ğŸŒ Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† DNS Ø¨Ù‡ Ø­Ø§Ù„Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø§Ú¯Ø± Ú¯ÛŒØªâ€ŒÙ„Ø¨ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯
    - name: "ğŸŒ Restore default DNS in resolved.conf if repo_source is gitlab"
      ansible.builtin.copy:
        content: |
          # This file is part of systemd.
          #
          # systemd is free software; you can redistribute it and/or modify it
          # under the terms of the GNU Lesser General Public License as published by
          # the Free Software Foundation; either version 2.1 of the License, or
          # (at your option) any later version.

          [Resolve]
          DNS=178.22.122.100 185.51.200.2
          #Domains=
          #LLMNR=yes
          #MulticastDNS=yes
          #DNSSEC=no
          #DNSOverTLS=no
          #Cache=yes
          #DNSStubListener=yes
          #ReadEtcHosts=yes
        dest: /etc/systemd/resolved.conf
        mode: '0644'
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1
      become: true

    # ğŸ”„ Ø§Ú¯Ø± repo_source Ø±ÙˆÛŒ gitlab Ø¨Ø§Ø´Ø¯ØŒ Ø³Ø±ÙˆÛŒØ³ systemd-resolved Ø±Ø§ Ù¾Ø³ Ø§Ø² Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ DNS Ù¾ÛŒØ´â€ŒÙØ±Ø¶ØŒ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ú©Ù†ÛŒØ¯.
    - name: "ğŸ”„ Restart systemd-resolved service after restoring default DNS if repo_source is gitlab"
      ansible.builtin.systemd:
        name: systemd-resolved
        state: restarted
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1
      become: true

    # ğŸ”— Ø§Ú¯Ø± repo_source Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ gitlab Ø¨Ø§Ø´Ø¯ØŒ Ù¾Ø³ Ø§Ø² Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ DNS Ù¾ÛŒØ´â€ŒÙØ±Ø¶ØŒ Ù„ÛŒÙ†Ú© Ù†Ù…Ø§Ø¯ÛŒÙ† Ø¨Ø±Ø§ÛŒ /etc/resolv.conf Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯.
    - name: "ğŸ”— Create symbolic link for /etc/resolv.conf after restoring default DNS if repo_source is gitlab"
      ansible.builtin.file:
        src: /run/systemd/resolve/resolv.conf
        dest: /etc/resolv.conf
        state: link
        force: true
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1
      become: true

    # ğŸ›  Ø§Ú¯Ø± repo_source Ø±ÙˆÛŒ gitlab Ø§Ø³ØªØŒ DNS Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ Ø¯Ø± /etc/resolv.conf ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯
    - name: "ğŸ›  Manually set default DNS in /etc/resolv.conf if repo_source is gitlab"
      ansible.builtin.copy:
        content: |
          nameserver 178.22.122.100
          nameserver 185.51.200.2
        dest: /etc/resolv.conf
        mode: '0644'
      when: repo_source == "gitlab" and customer_state == 'update'
      poll: 1
      become: true

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ú©Ù¾ÛŒ ÙØ§ÛŒÙ„ Ù‡Ø§
    # ğŸ“‚ Ø³Ø§Ø®Øª Ø¯Ø§ÛŒØ±Ú©ØªÙˆØ±ÛŒ init Ø¨Ø±Ø§ÛŒ gateway Ø¯Ø± ØµÙˆØ±Øª Ù†ÛŒØ§Ø²
    - name: "ğŸ“‚ Create gateway docker init directory if it does not exist"
      ansible.builtin.file:
        path: "{{ project_path }}/{{ inventory_hostname }}/gateway/docker/init"
        state: directory
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      delegate_to: localhost

    # ğŸ” Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯ Ú©Ù‡ Ø¢ÛŒØ§ ÙØ§ÛŒÙ„ SQL Ø®Ø§ØµÛŒ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯ ÛŒØ§ Ø®ÛŒØ±
    - name: "ğŸ” Check if specific SQL file exists"
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/sql/{{ inventory_hostname }}.sql"
      register: sql_file_check
      poll: 1
      delegate_to: localhost

    # ğŸ“¤ ÙØ§ÛŒÙ„ SQL Ù…Ù†Ø§Ø³Ø¨ Ø±Ø§ Ú©Ù¾ÛŒ Ú©Ù†ÛŒØ¯
    - name: "ğŸ“¤ Copy the appropriate SQL file"
      ansible.builtin.copy:
        src: "{{ sql_file_check.stat.exists | ternary(playbook_dir + '/sql/' + inventory_hostname + '.sql', playbook_dir + '/sql/default.sql') }}"
        dest: "{{ project_path }}/{{ inventory_hostname }}/gateway/docker/init/install.sql"
        mode: '0644'
      when: customer_state == 'update'
      poll: 1
      delegate_to: localhost

    # ğŸ§© Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ ÙØ§ÛŒÙ„ ZIP Ù…Ø®ØµÙˆØµ Ù…Ø´ØªØ±ÛŒ
    - name: "ğŸ§© Check if specific ZIP file exists"
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/sql/{{ inventory_hostname }}.zip"
      register: zip_file_check
      poll: 1
      delegate_to: localhost

    # ğŸ“¦ Ø§Ú¯Ø± ÙØ§ÛŒÙ„ ZIP ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªØŒ Ø¢Ù† Ø±Ø§ Ø§Ú©Ø³ØªØ±Ú©Øª Ú©Ù†
    - name: "ğŸ“¦ Unzip the specific ZIP file if it exists"
      ansible.builtin.unarchive:
        src: "{{ playbook_dir }}/sql/{{ inventory_hostname }}.zip"
        dest: "{{ project_path }}/{{ inventory_hostname }}/gateway/admin/uploads"
        remote_src: false
      when:
        - zip_file_check.stat.exists
        - customer_state == 'update'
      poll: 1
      delegate_to: localhost

    # ğŸ§¾ Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ bashUrl.js Ø¨Ø±Ø§ÛŒ portal-frontend
    - name: "ğŸ§¾ Create file for portal-frontend project"
      ansible.builtin.copy:
        dest: "{{ project_path }}/{{ inventory_hostname }}/portal-frontend/baseUrl.js"
        content: |
          const baseUrl = 'https://{{ customer_subdomain_backendportal }}.{{ customer_domain }}';
          export default baseUrl;
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # âš™ï¸ Ù…ØªØºÛŒØ±Ù‡Ø§ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ù…Ø­ØªÙˆØ§ÛŒ .env.local ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯
    - name: "âš™ï¸ Set variables for .env.local content"
      ansible.builtin.set_fact:
        database_url: "mysql://{{ pu }}:{{ pp }}@{{ customer_containers }}-portal-db:3306/{{ pd }}?serverVersion=10.11.2-MariaDB&charset=utf8mb4"
        base_url: "https://{{ customer_subdomain_gateway }}.{{ customer_domain }}"
      poll: 1
      when: customer_state == 'update'

    # ğŸŒ Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ .env.local Ø¨Ø±Ø§ÛŒ portal
    - name: "ğŸŒ Create file for portal project"
      ansible.builtin.copy:
        dest: "{{ project_path }}/{{ inventory_hostname }}/portal/.env.local"
        content: |
          DATABASE_URL="{{ database_url }}"
          BASE_URL="{{ base_url }}"
        mode: '0777'  # Ø³Ø·Ø­ Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ù†Ø§Ø³Ø¨ Ø¨Ø±Ø§ÛŒ ÙØ§ÛŒÙ„
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # ğŸ“ Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ my_database.php Ø¨Ø±Ø§ÛŒ gateway
    - name: "ğŸ“ Create my_database.php for gateway"
      ansible.builtin.copy:
        dest: "{{ project_path }}/{{ inventory_hostname }}/gateway/admin/application/config/my_database.php"
        content: |
          <?php defined('BASEPATH') OR exit('No direct script access allowed');
          $active_group = 'default';
          $query_builder = TRUE;
          $db['default'] = array(
              'dsn'  => '',
              'hostname' => '{{ customer_containers }}-gateway-db',
              'username' => '{{ gateway_mysql_user }}',
              'password' => '{{ gateway_mysql_password }}',
              'database' => '{{ gateway_mysql_db_name }}',
              'dbdriver' => 'mysqli',
              'dbprefix' => '',
              'pconnect' => FALSE,
              'db_debug' => (ENVIRONMENT !== 'production'),
              'cache_on' => FALSE,
              'cachedir' => '',
              'char_set' => 'utf8',
              'dbcollat' => 'utf8_general_ci',
              'swap_pre' => '',
              'encrypt' => FALSE,
              'compress' => FALSE,
              'stricton' => FALSE,
              'failover' => array(),
              'save_queries' => TRUE
          );
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # ğŸ§· Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ my_config.php Ø¨Ø±Ø§ÛŒ gateway
    - name: "ğŸ§· Create my_config.php for gateway"
      ansible.builtin.copy:
        dest: "{{ project_path }}/{{ inventory_hostname }}/gateway/admin/application/config/my_config.php"
        content: |
          <?php defined('BASEPATH') OR exit('No direct script access allowed');
          $config['base_url'] = "https://{{ customer_subdomain_gateway }}.{{ customer_domain }}";
        mode: '0777'
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø¨Ú©Ø§Ù¾ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø¬Ø±Ø§ Ùˆ Ø³Ø§Ø®Øª Ø´Ø¨Ú©Ù‡
    # ğŸ•µï¸ Ú†Ú© Ú©Ø±Ø¯Ù† ÙˆØ¬ÙˆØ¯ ÙØ§ÛŒÙ„ backup_volumes.sh
    - name: "ğŸ•µï¸ Check if backup_volumes.sh exists"
      ansible.builtin.stat:
        path: "{{ backup_path }}/{{ inventory_hostname }}/backup_volumes.sh"
      register: backup_script
      poll: 1
      when: customer_state == 'update'

    # â–¶ï¸ Ø§Ø¬Ø±Ø§ÛŒ Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ø¨Ú©Ø§Ù¾ Ø¨Ø±Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³â€ŒÙ‡Ø§ Ùˆ ÙˆÙ„ÙˆÙ…â€ŒÙ‡Ø§ ØªÙ†Ù‡Ø§ Ø¯Ø± ØµÙˆØ±ØªÛŒ Ú©Ù‡ ÙØ§ÛŒÙ„ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ø´Ø¯
    - name: â–¶ï¸ heck if backup script exists
      ansible.builtin.stat:
        path: "{{ backup_path }}/{{ inventory_hostname }}/backup_volumes.sh"
      register: backup_script
      poll: 1
      when: customer_state == 'update'

    # ğŸ’¾ Ø§Ø¬Ø±Ø§ÛŒ Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø­Ø¬Ù… Ù‡Ø§ Ùˆ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ù‡Ø§ÛŒ Ø¯Ø§Ø¯Ù‡
    - name: "ğŸ’¾ Run backup script for volumes and databases"
      ansible.builtin.shell: |
        bash "{{ backup_path }}/{{ inventory_hostname }}/backup_volumes.sh"
      register: backup_result
      async: 1800 # Ø­Ø¯Ø§Ú©Ø«Ø± Ø²Ù…Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø§Ø³Ú©Ø±ÛŒÙ¾Øª (Û³Û° Ø¯Ù‚ÛŒÙ‚Ù‡)
      poll: 1
      when: backup_script.stat.exists and customer_state == 'update'
      changed_when: true

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø§Ú©Ø± Ú©Ø§Ù…Ù¾ÙˆØ²Ø± gateway
    # ğŸ§© ÛŒØ§ÙØªÙ† Ù‡Ù…Ù‡ Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ gateway
    - name: "ğŸ§© Find all matching containers for gateway"
      ansible.builtin.shell: |
        docker ps -a --filter "name={{ customer_containers }}-gateway" --filter "name={{ customer_containers }}-gateway-db" -q
      register: matching_containers_gateway
      changed_when: false
      failed_when: false
      poll: 1
      when: customer_state in ['update', 'down']

    # ğŸ›‘ ØªÙˆÙ‚Ù Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ gateway
    - name: "ğŸ›‘ Stop matching containers for gateway"
      ansible.builtin.shell: |
        docker stop {{ matching_containers_gateway.stdout_lines | join(' ') }}
      when: matching_containers_gateway.stdout != "" and customer_state in ['update', 'down']
      register: stop_result
      poll: 1
      failed_when: stop_result.rc != 0 and '"No such container"' not in stop_result.stderr
      changed_when: stop_result.stdout != ""

    # âŒ Ú©Ø´ØªÙ† Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ (Ø¯Ø± ØµÙˆØ±Øª ØªÙˆÙ‚Ù Ù†Ø´Ø¯Ù†) Ø¨Ø±Ø§ÛŒ gateway
    - name: "âŒ Kill matching containers (if not already stopped) for gateway"
      ansible.builtin.shell: |
        docker kill {{ matching_containers_gateway.stdout_lines | join(' ') }} || true
      when: matching_containers_gateway.stdout != "" and customer_state in ['update', 'down']
      register: kill_result
      failed_when: false
      poll: 1
      changed_when: "'is not running' not in kill_result.stderr and kill_result.stdout != ''"

    # ğŸ§¹ Ø­Ø°Ù Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ gateway
    - name: "ğŸ§¹ Remove matching containers for gateway"
      ansible.builtin.shell: |
        docker rm {{ matching_containers_gateway.stdout_lines | join(' ') }}
      when: matching_containers_gateway.stdout != "" and customer_state in ['update', 'down']
      register: rm_result
      poll: 1
      failed_when: rm_result.rc != 0 and '"No such container"' not in rm_result.stderr
      changed_when: rm_result.stdout != ""

    # ğŸš€ Ø§Ø¬Ø±Ø§ÛŒ docker-compose Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³ gateway
    - name: "ğŸš€ Run docker-compose for gateway"
      ansible.builtin.command:
        cmd: docker compose -p {{ customer_containers }}-gateway -f "{{ project_path }}/{{ inventory_hostname }}/gateway/docker/docker-compose.yml" up -d
      # async: 1200
      poll: 1
      when: customer_state == 'update'
      register: docker_compose_job
      changed_when: false

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø§Ú©Ø± Ú©Ø§Ù…Ù¾ÙˆØ²Ø± portal
    # ğŸ§© ÛŒØ§ÙØªÙ† Ù‡Ù…Ù‡ Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ portal
    - name: "ğŸ§© Find all matching containers for portal"
      ansible.builtin.shell: |
        docker ps -a --filter "name={{ customer_containers }}-portal" --filter "name={{ customer_containers }}-portal-db" -q
      register: matching_containers_portal
      changed_when: false
      failed_when: false
      when: customer_state in ['update', 'down']
      poll: 1

    # ğŸ›‘ ØªÙˆÙ‚Ù Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ portal
    - name: "ğŸ›‘ Stop matching containers for portal"
      ansible.builtin.shell: |
        docker stop {{ matching_containers_portal.stdout_lines | join(' ') }}
      when: matching_containers_portal.stdout != "" and customer_state in ['update', 'down']
      register: stop_result
      failed_when: stop_result.rc != 0 and '"No such container"' not in stop_result.stderr
      poll: 1
      changed_when: stop_result.stdout != ""

    # âŒ Ú©Ø´ØªÙ† Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ (Ø¯Ø± ØµÙˆØ±Øª ØªÙˆÙ‚Ù Ù†Ø´Ø¯Ù†) Ø¨Ø±Ø§ÛŒ portal
    - name: "âŒ Kill matching containers (if not already stopped) for portal"
      ansible.builtin.shell: |
        docker kill {{ matching_containers_portal.stdout_lines | join(' ') }} || true
      when: matching_containers_portal.stdout != "" and customer_state in ['update', 'down']
      register: kill_result
      failed_when: false
      poll: 1
      changed_when: "'is not running' not in kill_result.stderr and kill_result.stdout != ''"

    # ğŸ§¹ Ø­Ø°Ù Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ portal
    - name: "ğŸ§¹ Remove matching containers for portal"
      ansible.builtin.shell: |
        docker rm {{ matching_containers_portal.stdout_lines | join(' ') }}
      when: matching_containers_portal.stdout != "" and customer_state in ['update', 'down']
      register: rm_result
      failed_when: rm_result.rc != 0 and '"No such container"' not in rm_result.stderr
      poll: 1
      changed_when: rm_result.stdout != ""

    # ğŸš€ Ø§Ø¬Ø±Ø§ÛŒ docker-compose Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³ portal
    - name: "ğŸš€ Run docker-compose for portal"
      ansible.builtin.command:
        cmd: docker compose -p {{ customer_containers }}-portal -f "{{ project_path }}/{{ inventory_hostname }}/portal/docker/docker-compose.yml" up -d
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø§Ú©Ø± Ú©Ø§Ù…Ù¾ÙˆØ²Ø± portal-frontend
    # ğŸ§© ÛŒØ§ÙØªÙ† Ù‡Ù…Ù‡ Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ portal-frontend
    - name: "ğŸ§© Find all matching containers for portal-frontend"
      ansible.builtin.shell: |
        docker ps -a --filter "name={{ customer_containers }}-portal-frontend" -q
      register: matching_containers_portal_frontend
      changed_when: false
      poll: 1
      failed_when: false
      when: customer_state in ['update', 'down']

    # ğŸ›‘ ØªÙˆÙ‚Ù Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ portal-frontend
    - name: "ğŸ›‘ Stop matching containers for portal-frontend"
      ansible.builtin.shell: |
        docker stop {{ matching_containers_portal_frontend.stdout_lines | join(' ') }}
      when: matching_containers_portal_frontend.stdout != "" and customer_state in ['update', 'down']
      register: stop_result
      failed_when: stop_result.rc != 0 and '"No such container"' not in stop_result.stderr
      poll: 1
      changed_when: stop_result.stdout != ""

    # âŒ Ú©Ø´ØªÙ† Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ (Ø¯Ø± ØµÙˆØ±Øª ØªÙˆÙ‚Ù Ù†Ø´Ø¯Ù†) Ø¨Ø±Ø§ÛŒ portal-frontend
    - name: "âŒ Kill matching containers (if not already stopped) for portal-frontend"
      ansible.builtin.shell: |
        docker kill {{ matching_containers_portal_frontend.stdout_lines | join(' ') }} || true
      when: matching_containers_portal_frontend.stdout != "" and customer_state in ['update', 'down']
      register: kill_result
      failed_when: false
      poll: 1
      changed_when: "'is not running' not in kill_result.stderr and kill_result.stdout != ''"

    # ğŸ§¹ Ø­Ø°Ù Ú©Ø§Ù†ØªÛŒÙ†Ø±Ù‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¨Ø§ Ø³Ø±ÙˆÛŒØ³ portal-frontend
    - name: "ğŸ§¹ Remove matching containers for portal-frontend"
      ansible.builtin.shell: |
        docker rm {{ matching_containers_portal_frontend.stdout_lines | join(' ') }}
      when: matching_containers_portal_frontend.stdout != "" and customer_state in ['update', 'down']
      register: rm_result
      failed_when: rm_result.rc != 0 and '"No such container"' not in rm_result.stderr
      poll: 1
      changed_when: rm_result.stdout != ""

    # ğŸš€ Ø§Ø¬Ø±Ø§ÛŒ docker-compose Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³ portal-frontend
    - name: ğŸš€ Run docker-compose for portal-frontend
      ansible.builtin.command:
        cmd: >
          docker compose -p {{ inventory_hostname }}-portal-frontend
          -f "{{ project_path }}/{{ inventory_hostname }}/portal-frontend/docker/docker-compose.yml"
          up -d
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ù…ÛŒÚ¯Ø±ÛŒØ´Ù† Ø¯Ø± Ú©Ø§Ù†ØªÛŒÙ†Ø± Ù¾Ø±ØªØ§Ù„ Ùˆ Ù†ØµØ¨ Ú©Ø§Ù…Ù¾ÙˆØ²Ø±
    # ğŸ¼ Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø³ØªÙˆØ± composer install Ø¯Ø§Ø®Ù„ Ú©Ø§Ù†ØªÛŒÙ†Ø±
    - name: "ğŸ¼ Run composer install inside the container"
      community.docker.docker_container_exec:
        container: "{{ customer_containers }}-portal"
        command: composer install
      register: composer_output
      poll: 1
      when: customer_state == 'update'

    # ğŸ“œ Ù†Ù…Ø§ÛŒØ´ Ø®Ø±ÙˆØ¬ÛŒ Ø§Ø¬"Ø±Ø§ÛŒ composer install
    - name: "ğŸ“œ Show composer install output"
      ansible.builtin.debug:
        msg: |
          STDOUT:
          {{ composer_output.stdout }}
          STDERR:
          {{ composer_output.stderr }}
      when: customer_state == 'update'
      poll: 1

    # ğŸ©º Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø§Ø¬Ø±Ø§ÛŒ Ú©Ø§Ù†ØªÛŒÙ†Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    - name: "ğŸ©º Check if DB container is running"
      community.docker.docker_container_info:
        name: "{{ customer_containers }}-portal-db"
      register: db_container_info
      poll: 1
      when: customer_state == 'update'

    # ğŸ”¼ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ú©Ø§Ù†ØªÛŒÙ†Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¯Ø± ØµÙˆØ±Øª Ø§Ø¬Ø±Ø§ Ù†Ø´Ø¯Ù†
    - name: "ğŸ”¼ Start the DB container if it's not running"
      community.docker.docker_container:
        name: "{{ customer_containers }}-portal-db"
        state: started
      when: not db_container_info.container.State.Running | default(false) and customer_state == 'update'
      poll: 1

    # ğŸ›  ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¯Ø± ØµÙˆØ±Øª Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯
    - name: "ğŸ›  Try to create database if it does not exist"
      community.docker.docker_container_exec:
        container: "{{ customer_containers }}-portal"
        command: php bin/console doctrine:database:create --env=prod --if-not-exists
      register: db_create_result
      ignore_errors: true
      poll: 1
      when: customer_state == 'update'

    # ğŸ§¬ Ø§Ø¬Ø±Ø§ÛŒ Ù…Ù‡Ø§Ø¬Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÚ¯Ø§Ù‡â€ŒØ¯Ø§Ø¯Ù‡ Ø§Ú¯Ø± Ø³Ø§Ø®Øª Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯ ÛŒØ§ Ù†ÛŒØ§Ø² Ù†Ø¨ÙˆØ¯
    - name: "ğŸ§¬ Run migrations if database creation succeeded or was skipped"
      community.docker.docker_container_exec:
        container: "{{ customer_containers }}-portal"
        command: php bin/console doctrine:migrations:migrate --no-interaction --env=prod
      when: customer_state == 'update' and db_create_result is not failed
      poll: 1

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø³Ø§ÛŒØ±
    # ğŸ“„ Ù†ÙˆØ´ØªÙ† Ù„ÛŒØ³Øª Ø­Ø¬Ù…â€ŒÙ‡Ø§ÛŒ Ø§ÛŒØ³ØªØ§ (Static Volumes) Ø¯Ø± ÙØ§ÛŒÙ„
    - name: "ğŸ“„ Write static volume list to file"
      ansible.builtin.copy:
        content: |
          gateway/admin/uploads
          gateway/admin/captcha_images
          gateway/admin
          portal
          portal-frontend
        dest: "{{ info_path }}/volumes/{{ inventory_hostname }}.txt"
        mode: '0777'
      poll: 1
      when: customer_state == 'update'

    # ğŸŸ¢ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§ Ø¨ÙˆØ¯Ù† Ú©Ø§Ù†ØªÛŒÙ†Ø±
    - name: "ğŸŸ¢ Ensure container is running"
      community.docker.docker_container:
        name: "{{ customer_containers }}-gateway"
        state: started
      poll: 1
      when: customer_state == 'update'

    # âœï¸ Ø¯Ø§Ø¯Ù† Ø³Ø·Ø­ Ø¯Ø³ØªØ±Ø³ÛŒ Ù†ÙˆØ´ØªÙ† Ø¨Ù‡ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ Ú©Ø§Ù†ØªÛŒÙ†Ø±
    - name: "âœï¸ Grant write permissions to folders in the container"
      community.docker.docker_container_exec:
        container: "{{ customer_containers }}-gateway"
        command: "chmod -R 777 uploads captcha_images"
      when: customer_state == 'update'
      poll: 1

    # ğŸ“¦ Ø§Ø¬Ø±Ø§ÛŒ Ù…Ù‡Ø§Ø¬Ø±Øª (migration) Ø¨Ø±Ø§ÛŒ Ø³Ø±ÙˆÛŒØ³ gateway
    - name: "ğŸ“¦ Migration for gateway"
      community.docker.docker_container_exec:
        container: "{{ customer_containers }}-gateway"
        command: "php index.php migrate index false"
      when: customer_state == 'update'
      poll: 1

    # ğŸ§¾ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø§ÛŒÚ¯Ø§Ù‡â€ŒØ¯Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ
    - name: "ğŸ§¾ Extract database information for each customer"
      ansible.builtin.shell: |
        # Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù…Ø­ØªÙˆÛŒØ§Øª Ù‚Ø¨Ù„ÛŒ ÙØ§ÛŒÙ„
        > "{{ info_path }}/databases/{{ inventory_hostname }}.txt"

        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø§Ø² ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¬Ø¯ÛŒØ¯ Ansible
        DB_TYPE="{{ portal_database_type }}"
        DB_NAME="{{ portal_mysql_db_name }}"
        DB_USER="{{ portal_mysql_user }}"
        DB_PASSWORD="{{ portal_mysql_password }}"
        DB_HOST="{{ customer_containers }}-portal-db"
        echo "$DB_TYPE,$DB_NAME,$DB_USER,$DB_PASSWORD,$DB_HOST" > "{{ info_path }}/databases/{{ inventory_hostname }}.txt"

        DB_TYPE="{{ gateway_database_type }}"
        DB_NAME="{{ gateway_mysql_db_name }}"
        DB_USER="{{ gateway_mysql_user }}"
        DB_PASSWORD="{{ gateway_mysql_password }}"
        DB_HOST="{{ customer_containers }}-gateway-db"
        echo "$DB_TYPE,$DB_NAME,$DB_USER,$DB_PASSWORD,$DB_HOST" >> "{{ info_path }}/databases/{{ inventory_hostname }}.txt"
      register: db_info_result
      when: customer_state == 'update'
      poll: 1
      changed_when: false

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Ø¨Ú©Ø§Ù¾ Ú¯Ø±ÙØªÙ†
    # ğŸ“¤ Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ø¨Ú©Ø§Ù¾ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø±ÙˆÛŒ Ø³Ø±ÙˆØ±
    - name: "ğŸ“¤ Copy volume backup script to the server"
      ansible.builtin.copy:
        content: |
          #!/bin/bash

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Ù…Ø³ÛŒØ± Ø¨Ú©Ø§Ù¾
          BACKUP_DIR="{{ backup_path }}/{{ inventory_hostname }}/$(date +'%Y-%m-%d-%H-%M-%S')"
          mkdir -p $BACKUP_DIR
          chmod 777 "$BACKUP_DIR"

          # ÙØ§ÛŒÙ„ Ú¯Ø²Ø§Ø±Ø´
          BACKUP_LOG="{{ log_path }}/backup/{{ inventory_hostname }}_volumes.txt"
          save_log "ğŸš€ Volume backup started at $(date)"

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Ø¨Ø±Ø±Ø³ÛŒ ÙØ¶Ø§ÛŒ Ø¯ÛŒØ³Ú©
          REQUIRED_SPACE_MB=100
          AVAILABLE_SPACE_MB=$(df "$BACKUP_DIR" | awk 'NR==2 {print int($4/1024)}')
          if (( AVAILABLE_SPACE_MB < REQUIRED_SPACE_MB )); then
            save_log "ğŸ–´âŒ Not enough disk space. Required: ${REQUIRED_SPACE_MB}MB, Available: ${AVAILABLE_SPACE_MB}MB"
            exit 1
          fi

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Ú¯Ø±ÙØªÙ† Ù„ÛŒØ³Øª Ø§Ø² ÙˆÙ„ÙˆÙ…â€ŒÙ‡Ø§ Ø§Ø² ÙØ§ÛŒÙ„ Ù…Ø®ØµÙˆØµ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ
          VOLUMES=$(head -n 1 {{ info_path }}/volumes/{{ inventory_hostname }}.txt)

          # Ù…Ø³ÛŒØ± Ù¾Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ÙˆÙ„ÙˆÙ…â€ŒÙ‡Ø§
          VOLUME_BASE="{{ project_path }}/{{ inventory_hostname }}"

          # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ø± Ù…Ø³ÛŒØ± Ø¯Ø± Ø§ÙˆÙ† ÛŒÚ© Ø®Ø·
          for VOLUME in $VOLUMES; do
            # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù…Ø³ÛŒØ± Ù¾Ø§ÛŒÙ‡
            FULL_VOLUME_PATH="$VOLUME_BASE/$VOLUME"

            # Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ÙˆØ¬ÙˆØ¯ Ù¾ÙˆØ´Ù‡
            if [ ! -d "$FULL_VOLUME_PATH" ]; then
              save_log "ğŸ“âŒ Volume $FULL_VOLUME_PATH does not exist!"
              continue
            fi

            ARCHIVE_NAME=$(basename "$FULL_VOLUME_PATH")
            BACKUP_FILE="$BACKUP_DIR/$ARCHIVE_NAME.tar.gz"

            # Ø¨Ø±Ø±Ø³ÛŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ¬ÙˆØ¯ ÙØ§ÛŒÙ„ Ø¨Ú©Ø§Ù¾
            if [ -f "$BACKUP_FILE" ]; then
              save_log "ğŸ“âŒ Backup file $BACKUP_FILE already exists. Skipping."
              continue
            fi

            # Ú¯Ø±ÙØªÙ† Ø¨Ú©Ø§Ù¾ Ø§Ø² Ù¾ÙˆØ´Ù‡ Ø¨Ø§ Ø¯Ø³ØªÙˆØ± tar
            save_log "ğŸ“ Starting backup for volume $FULL_VOLUME_PATH..."
            tar czf "$BACKUP_FILE" -C "$FULL_VOLUME_PATH" .

            # Ø¨Ø±Ø±Ø³ÛŒ Ù…ÙˆÙÙ‚ÛŒØª Ø¢Ù…ÛŒØ² Ø¨ÙˆØ¯Ù† Ø¹Ù…Ù„ÛŒØ§Øª tar
            if [ $? -eq 0 ]; then
              save_log "ğŸ“âœ… Backup for volume $FULL_VOLUME_PATH completed successfully at $(date)"
            else
              save_log "ğŸ“âŒ Error during backup of volume $FULL_VOLUME_PATH"
            fi
          done

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          save_log "ğŸ Volume backup completed at $(date)"
          save_log "----------------------------------------------------------------------------------"

          # ØªØ§Ø¨Ø¹ Ø°Ø®ÛŒØ±Ù‡ Ù„Ø§Ú¯
          save_log() {
            local message="$1"
            echo "$message" | tee -a "$BACKUP_LOG" | logger -t backup_volumes
          }
        dest: "{{ backup_path }}/{{ inventory_hostname }}/backup_volumes.sh"
        mode: '0777'  # Ø§Ø¹Ø·Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø§Ø¬Ø±Ø§ÛŒÛŒ Ø¨Ù‡ Ø§Ø³Ú©Ø±ÛŒÙ¾Øª
      when: customer_state == 'update'
      poll: 1

    # ğŸ“¤ Ú©Ù¾ÛŒ Ú©Ø±Ø¯Ù† Ø§Ø³Ú©Ø±ÛŒÙ¾Øª Ø¨Ú©Ø§Ù¾ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±ÙˆÛŒ Ø³Ø±ÙˆØ±
    - name: "ğŸ“¤ Copy database backup script to the server"
      ansible.builtin.copy:
        content: |
          #!/bin/bash

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Ù…Ø³ÛŒØ± Ø¨Ú©Ø§Ù¾
          BACKUP_DIR="{{ backup_path }}/{{ inventory_hostname }}/$(date +'%Y-%m-%d-%H-%M-%S')"
          mkdir -p $BACKUP_DIR
          chmod 777 "$BACKUP_DIR"

          # ÙØ§ÛŒÙ„ Ú¯Ø²Ø§Ø±Ø´
          BACKUP_LOG="{{ log_path }}/backup/{{ inventory_hostname }}_databases.txt"
          save_log "ğŸš€ Database backup started at $(date)"

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Ø¨Ø±Ø±Ø³ÛŒ ÙØ¶Ø§ÛŒ Ø¯ÛŒØ³Ú©
          REQUIRED_SPACE_MB=100
          AVAILABLE_SPACE_MB=$(df "$BACKUP_DIR" | awk 'NR==2 {print int($4/1024)}')
          if (( AVAILABLE_SPACE_MB < REQUIRED_SPACE_MB )); then
            save_log "ğŸ–´âŒ Not enough disk space. Required: ${REQUIRED_SPACE_MB}MB, Available: ${AVAILABLE_SPACE_MB}MB"
            exit 1
          fi

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Ú¯Ø±ÙØªÙ† Ù„ÛŒØ³Øª Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³â€ŒÙ‡Ø§ Ø§Ø² ÙØ§ÛŒÙ„ Ù…Ø®ØµÙˆØµ Ù‡Ø± Ù…Ø´ØªØ±ÛŒ
          DATABASES="{{ info_path }}/databases/{{ inventory_hostname }}.txt"

          while IFS=',' read -r DB_TYPE DB_NAME DB_USER DB_PASSWORD DB_CONTAINER; do
            if [[ "$DB_TYPE" == "mysql" ]]; then
              BACKUP_FILE="$BACKUP_DIR/${DB_NAME}-mysql.sql.gz"
              save_log "ğŸ›¢ï¸ Backing up MySQL database $DB_NAME..."

              # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² docker exec Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª Ø¯Ø± Ø¯Ø§Ø®Ù„ Ú©Ø§Ù†ØªÛŒÙ†Ø± MySQL
              docker exec $DB_CONTAINER mysqldump -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" 2>>"$BACKUP_LOG" | gzip > "$BACKUP_FILE"

              if [[ $? -eq 0 ]]; then
                chmod 0777 "$BACKUP_FILE"
                save_log "ğŸ›¢ï¸âœ… MySQL backup for $DB_NAME completed at $(date)"
              else
                save_log "ğŸ›¢ï¸âŒ Error backing up MySQL database $DB_NAME"
              fi

            elif [[ "$DB_TYPE" == "postgresql" ]]; then
              BACKUP_FILE="$BACKUP_DIR/${DB_NAME}-postgresql.sql.gz"
              save_log "ğŸ˜ Backing up PostgreSQL database $DB_NAME..."

              # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² docker exec Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª Ø¯Ø± Ø¯Ø§Ø®Ù„ Ú©Ø§Ù†ØªÛŒÙ†Ø± PostgreSQL
              docker exec $DB_CONTAINER pg_dump -U "$DB_USER" -h "$DB_HOST" -d "$DB_NAME" 2>>"$BACKUP_LOG" | gzip > "$BACKUP_FILE"

              if [[ $? -eq 0 ]]; then
                chmod 0777 "$BACKUP_FILE"
                save_log "ğŸ˜âœ… PostgreSQL backup for $DB_NAME completed at $(date)"
              else
                save_log "ğŸ˜âŒ Error backing up PostgreSQL database $DB_NAME"
              fi
            fi
          done < "$DATABASES"

          # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          save_log "ğŸ Database backup completed at $(date)"
          save_log "----------------------------------------------------------------------------------"

          # ØªØ§Ø¨Ø¹ Ø°Ø®ÛŒØ±Ù‡ Ù„Ø§Ú¯
          save_log() {
            local message="$1"
            echo "$message" | tee -a "$BACKUP_LOG" | logger -t backup_databases
          }
        dest: "{{ backup_path }}/{{ inventory_hostname }}/backup_databases.sh"
        mode: '0777'  # Ø§Ø¹Ø·Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø§Ø¬Ø±Ø§ÛŒÛŒ Ø¨Ù‡ Ø§Ø³Ú©Ø±ÛŒÙ¾Øª
      when: customer_state == 'update'
      poll: 1

    # â° ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ú©Ø§Ù¾ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² cron
    - name: "â° Set up cron job for volume backup"
      ansible.builtin.cron:
        name: "Backup Docker Volumes"
        minute: "0"
        hour: "0"
        day: "*"
        weekday: "0"  # Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ú©Ø§Ù¾ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ù‡Ø± ÛŒÚ©Ø´Ù†Ø¨Ù‡ Ø³Ø§Ø¹Øª 00:00
        job: "/bin/bash {{ backup_path }}/{{ inventory_hostname }}/backup_volumes.sh"
        user: root
        state: present
      poll: 1
      when: customer_state == 'update'

    # â° ØªÙ†Ø¸ÛŒÙ… Ø²Ù…Ø§Ù†â€ŒØ¨Ù†Ø¯ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ú©Ø§Ù¾ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² cron
    - name: "â° Set up cron job for database backup"
      ansible.builtin.cron:
        name: "Backup Databases"
        minute: "30"
        hour: "0,8,16"  # Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ú©Ø§Ù¾ Ø¯ÛŒØªØ§Ø¨ÛŒØ³â€ŒÙ‡Ø§ Ø³Ù‡ Ø¨Ø§Ø± Ø¯Ø± Ø±ÙˆØ² (0:30ØŒ 8:30ØŒ 16:30)
        job: "/bin/bash {{ backup_path }}/{{ inventory_hostname }}/backup_databases.sh"
        user: root
        state: present
      poll: 1
      when: customer_state == 'update'
